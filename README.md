# Тестовое задание – вакансия разработчик C++/Qt/Linux

Реализация алгоритма расчета параметров карты коррекции битых пикселей рентгеновского детектора и теста для его проверки. Консольное приложение Linux.


## Содержание
1. [Начало](#Начало)
2. [Инструментарий](#Инструментарий)
3. [Требования](#Требования)
4. [Описание данных](#Описание данных)
5.[Подсказка по OpenCV](#Подсказка по OpenCV)
6. [Описание алгоритма коррекции битых пикселей](#Описание алгоритма коррекции битых пикселей)
7. [Тестирование](#Тестирование)

## Начало
В приложении тестовый файл «test.png», совмещающий в себе битые пиксели и эмуляцию полезного сигнала.
![alt text][logo]

[logo]:https://imgur.com/qX02KdD "View in the Editor"
Реальный тестовый файл в формате TIFF 16 bit – «test real.tiff»

## Инструментарий
C++, std::. Для загрузки и отображение обработанного изображения можно использовать любой удобный фреймворк, преимущество за OpenCV.

## Требования

Алгоритм выполняется один раз при загрузке нескорректированного изображения с детектора.

По указанному изображению строится карта битых пикселей.

Затем результаты работы алгоритма (параметры, файл бытых пикселей) используются для realtime коррекции на GPU. 

Поэтому скорость работы алгоритма и потребляемая память не важны. Первостепенна корректность нахождения битых пикселей.

На выходе должен быть готовый проект, а также исполняемый файл создающий карту битых пикселей в виде изображения.


## Описание данных

Двумерное изображения, получаемое с детектора, может содержать ряд дефектных (битых) пикселей. Они могут быть "холодные" (значение близкое к нулю), "горячие" (близкое к максимуму) и прочие (мигающие, прыгающие, нелинейная передача яркости).

В целях обеспечения комфортной работы с изображением, такие пиксели требуют коррекции (замазывания). аналогичные алгоритмы применяются на всех бытовых и промышленных фотоаппаратах, видеокамерах и пр.

Изображение с детектора в градациях серого (один канал), типичные размеры до 4096 х 4096 точек. В качестве входных данных в алгоритм поступает изображение соответствующего размера, в котором дефектные пиксели отмечены светлым цветом (интенсивность более 50%). Остальные пиксели считаются не битыми. Тестовая картинка подготовлена, исходя из данного предположения. Белые точки на ней – битые пиксели, темные градиенты – симуляция реального изображения для проведения тестирования по тому же самому изображению.

Выходными данными является ``` std::shared_ptr<std::vector<float[14]>>```. Каждый компонент ``` std::vector:float[14] {X0, Y0, x1, y1, w1, x2, y2, w2, x3, y3, w3, x4, y4, w4}```,
где (X0, Y0) – координаты битого пикселя. (xi, yi) – координаты исправного пикселя-соседа, wi – весовой коэффициент. Если имеется менее 4х соседей, то соответствующие xi, yi и wi = 0.0f.

Коррекция осуществляется путем перебора всех соседей, умножением их интенсивностей на wi, суммированием и помещением результата в точку (X0, Y0). Соответственно сумма всех wi должна бать равно 1.0f.

Realtime коррекция осуществляется на GPU (OpenGL), координаты должны быть подготовлены определенным образом. Координаты (X0, Y0) должны быть выражены в экранных координатах OpenGL – (0.0f, 0.0f) – центр изображения, (1.0f, 1.0f) – правый верхний угол. (-1.0f, -1.0f) – левый нижних. Т.е. обычные декартовы координаты. Координаты (xi, yi) – текстурные координаты OpenGL. В них (0.0f, 0.0f) – левый нижний край изображения, (1.0f, 1.0f) – правый верхний. Различие в координатных системах определяется тем, что первые используются для вывода результата, вторые – для семплирования текстуры. Важно отметить, что координаты должны указывать именно на центр пикселя, не на его край. Т.е. нужно учесть смещение в пол пикселя по отношению к привычным целочисленным координатам.

### Подсказка по OpenCV

Изображение загружается с помощью cv::imread(). Для удобства можно применить стандартные средства OpenCV для конвертации формата, если необходимо. Если для алгоритма удобнее, что бы изображение находилось в памяти гарантированной непрерывно (без возможных промежутков после каждой строки), можно использовать if (!mat.isContinuous()) mat = mat.clone(), где mat – изображение OpenCV.


## Описание алгоритма коррекции битых пикселей
Находим очередной битый пиксель (интенсивность более 50%).

Сначала пытаемся найти линии интерполяции по горизонтали (ищем ближайший исправный пиксель слева и справа), и по вертикали. Пиксели ищем на расстоянии не более ``` MAX_DISTANCE``` .

Если найдена обе полные линии (в каждой есть начальная и конечная точки), то проверяем, каково максимальное расстояние до граничных точек в каждой из этих линий. Если разница в максимальных расстояниях менее ``` DISTANCE_DIFFERENCE_THRESHOLD``` , то используем обе, иначе ту, в которой расстояние меньше. Это сделано для приоритетной коррекции по более близким точкам.

Весовые коэффициенты рассчитываем, исходя из реальных расстояний от концов линии до точки коррекции путем линейной интерполяции. Если используются обе линии интерполяции, то их вклад в коррекцию считается одинаковым, т.е. весовые коэффициенты всех их точек умножаются на 0.5f, что бы сумма wi была равно 1.0f.

Начальная или конечные точки линии интерполяции могут быть не найдены, если они расположены от точки коррекции на расстоянии более ``` MAX_DISTANCE``` , а там же если достигнута граница экрана.

Если не найдена ни вертикальная, ни горизонтальная линии интерполяции, проводим аналогичных поиск по 2м диагоналям. ``` MAX_DISTANCE```  для отсечки в данном случае можно считать в количестве шагов, а не в реальном расстоянии, т.е. ближайший пиксель по диагонали – расстояние 1, следующий 2 и т.д.

Если не найдена ни одна полная диагональ, то проводим усреднение по ближайшим имеющимся точкам сверху-снизу-слева-справа (из первого прохода). Весовые коэффициенты в данном случае считаем одинаковыми, равными 1.0f / количество_точек, т.е. без учета расстояний.

Повторяем для всех битых пикселей.


## test

После расчета данных коррекции необходимо применить их непосредственно к карте битых пикселей и вывести изображения на экран с помощью. ``` Cv::imshow()``` .

